%! TEX program = lualatex
\documentclass[12pt]{article}
\usepackage[paper=a4paper,margin=0.6cm]{geometry}
\usepackage{luacode}
\usepackage{prettytok}
\ExplSyntaxOn \prettyinit: \ExplSyntaxOff
\usepackage{precattl}
\usepackage{genvar}
\usepackage{imperative}
\AutoGenerateVariants
\errorcontextlines=100
\begin{document}

\iffalse
\ExplSyntaxOn
\makeatletter

\rdeflinenumbered\f {}!
\assigno #x {\use:n{123}}
\return {#x}
!

\directlua{optimize_pending_definitions()}
\directlua{debug_rdef()}
\directlua{debug_rdef2()}
\directlua{execute_pending_definitions()}

\end{document}
\fi

\iffalse
\ExplSyntaxOn
\makeatletter

\addlinemarkerconditionalb{\pretty:n} !
123
123%
\linemarkeron
123%
456%
\linemarkeroff
789

!

\makeatother
\ExplSyntaxOff

\end{document}
\fi

\iffalse
\ExplSyntaxOn
\makeatletter


\putnextwithexpand{
	\a \b
}{
	\expandat \b
	\expandat \b
	\expandat \b
}

\putnextwithexpand{
	* \a ! \b
}{
	\onlabel * \expandatlabel !
	\onlabel * \expandatlabel !
}

\putnextwithexpand{
	\f { \argi } { \argii }
}{
	\expandat \argii
	\expandat \argi
}

\putnextwithexpand{
	\f { \x } \g { \y }
}{
	\expandat \x
	\before \g \expandat \y
}

\putnextwithexpand{
	\f #1 {\x}
}{
	\assertissingletoken {#1}
	\expandat \x
}

\putnextwithexpand{
	\f #1 {\x}
}{
	\assertissingletoken {#1}
	\expandat \x
}

\putnextwithexpand{
	\f \csname #1 \endcsname {\x}
}{
	\expandat \csname
	\before \endcsname \expandat \x
}

\putnextwithexpand{
	\a \b \c \d \e
}{
	\expandat \d
	\expandat \c
	\expandat \b
}


\putnextwithexpand {
	%% '\Iremovebgroup{' expands to nothing in one step, but "balance" as one '{'.
	% internally \iffalse { \fi
	\Iremovebgroup{
	* \use_none:n {{ \string #1 } \@@casei } \@@caseii } \use_i:nn
}
{
	%% \putnextwithexpand second argument syntax:

	% \expandat ...
	% \expandatlabel ...

	% \onlabel ... \expandat ...
	% \after ... \expandat[label] ...
	% \before ... \expandat[label] ...

	% the token/token sequence must appear exactly once.
	% Optional braces in "..." are stripped. "..." can be sequence of tokens.
	\onlabel * \expandat \string
	%\expandat \string
}


\end{document}
\fi

\iffalse

\precattl_exec:n{
\def\testtest{
	\pretty:n{========}
	\endlinechar=13\relax
	\newlinechar=13\relax
	\tl_set_rescan:Nnn \__result { \endlinechar=32\relax } { a \cO\% b \cO\^^M c \cO\^^M d }   \pretty:V \__result
	\tl_set_rescan:Nnn \__result { \endlinechar=32\relax } { a \cO\% b \cO\^^J c \cO\^^J d }   \pretty:V \__result
	\tl_set_rescan:Nnn \__result { \endlinechar=32\relax } { a \cO\% b \cO\    c \cO\    d }   \pretty:V \__result
	\pretty:n{========}
}
}

\testtest


\ExplSyntaxOff
\testtest
\ExplSyntaxOn

\fi

\iffalse
\ExplSyntaxOn
\makeatletter


\precattl_exec:n{
\pretty:x {
\__process_s \cO{ 0a.B 0b.B 0c.1 0d.2 0e.3 0f.4 0#.6 0g.6 0h.7 0i.8 0j.B 0k.C 0l.D 1 2abc\^^A  2}\cS\ \cO{\^^A 2j\^^A 3 }
}
}

\rdeflinenumbered \a #1 {} !
	\return {#1 #1}
!

\rdeflinenumbered \b #1 {} !
	\backquote{
		\return {,r{\a { ,r{\a} }}}
	}
!




\end{document}
\fi

\iffalse
\ExplSyntaxOn
\makeatletter




\rdeflinenumbered \f {
	\assign #x{1}
	\assign #y{2}
	\conditional{\use_i:nn} {
		\assigno #x{\the\numexpr #x+1\relax}
	} {
		\assigno #y{\the\numexpr #y+1\relax}
	}
	\return {{#x}{#y}}
}

\rdeflinenumbered \g {
	\putnext{\string} \expandonce
	\matchrm{#1}
	\rcall{\removeuntilegroup}
}

\rdeflinenumbered \exchange {}!
%\rdef \exchange {
	\matchrm{#x}
	\matchrm{#y}
	\return{{#y}{#x}}

	% test something

	\assignoperate #x{123}{
		\matchrm{#y}
	}

	\conditional{\izfblank{#x}}{
		\assign #x{true}
	}{
		\assign #x{false}
	}

	\matchrm{#y#}

	\while{}{\izfblank{#x}}{\assigno #x{\tail{#x}}}

	\assertisNtype #x
	\expandonce
	\putnext{#x abc}

	\assign #x{12}
	\putnext{#x abc}

	\assertisNtype #x
	\putnext{#x abc}
!

\fi

\ExplSyntaxOn
\makeatletter


%\odef \removespace \cS\ {}  % (low-level) def that expands to result in single step. Identical to \def in TeX.
\rdeflinenumbered \removespace #x {}!
	\assignoperate #\result {#x} {\matchrm { ~ }}
	\return{#\result}
!

\addlinemarkerconditionalb {} !
\locallyset@@to{@ifempty@}{  % in control sequence names only. Argument must be list of "normal" character tokens.
	\zdef \ifempty #1 {

\linemarkeron

		\putnextwithexpand {
			%% '\Iremovebgroup{' expands to nothing in one step, but "balance" as one '{'.
			% internally \iffalse { \fi
			\Iremovebgroup{
			* \use_none:n {{ \string #1 } \@@casei } \@@caseii } \use_i:nn
		}
		{
			%% \putnextwithexpand second argument syntax:

			% \expandat ...
			% \expandatlabel ...

			% \onlabel ... \expandat ...
			% \after ... \expandat[label] ...
			% \before ... \expandat[label] ...

			% the token/token sequence must appear exactly once.
			% Optional braces in "..." are stripped. "..." can be sequence of tokens.
			\onlabel * \expandat \string
			%\expandat \string
		}


\linemarkeroff

	}

	% case 0: #1 is none. Then
	%     \use_none:n {{ \string #1 }  \@@casei } \@@caseii } \use_i:nn
	% expands to
	%     \use_none:n {{           '}' \@@casei } \@@caseii } \use_i:nn
	% and subsequently
	%                                                         \use_i:nn

	% case 1: #1 starts with a single brace. Then
	%     \use_none:n {{ \string #1 }  \@@casei } \@@caseii } \use_i:nn
	% expands to
	%     \use_none:n {{ ... } ...  }  \@@casei } \@@caseii } \use_i:nn
	% and subsequently
	%                                  \@@casei } \@@caseii } \use_i:nn

	% case 2: #1 starts with some other token. Then
	%     \use_none:n {{ \string #1 }  \@@casei } \@@caseii } \use_i:nn
	% expands to
	%     \use_none:n {{ ...        }  \@@casei } \@@caseii } \use_i:nn
	% and subsequently
	%                                             \@@caseii } \use_i:nn

	\zdef \@@casei {  % such that '\@@casei } \@@caseii } \use_i:nn' expands to \use_ii:nn
\linemarkeron
		\rcall{\removenextegroup}
		% pass control to \@@caseii
\linemarkeroff
	}

	\zdef \@@caseii {
\linemarkeron
		\rcall{\removenextegroup}
		\matchrm{#1}  % the \use_i:nn token
		\putnext {\use_ii:nn}
\linemarkeroff
	}
}


\locallyset@@to{@ifbrace@}{
	\zdef \ifbrace #1 {
\linemarkeron
		\putnextwithexpand {
			\Iremovebgroup{
			* \use_none:n {{ \string #1 } \@@casei } \@@caseii } \use_ii:nn
		}
		{
			\onlabel * \expandat \string
		}
\linemarkeroff
	}

	% case 0: #1 is none. Then
	%     \use_none:n {{ \string #1 }  \@@casei } \@@caseii } \use_ii:nn
	% expands to
	%     \use_none:n {{           '}' \@@casei } \@@caseii } \use_ii:nn
	% and subsequently
	%                                                         \use_ii:nn

	% case 1: #1 starts with a single brace. Then
	%     \use_none:n {{ \string #1 }  \@@casei } \@@caseii } \use_ii:nn
	% expands to
	%     \use_none:n {{ ... } ...  }  \@@casei } \@@caseii } \use_ii:nn
	% and subsequently
	%                                  \@@casei } \@@caseii } \use_ii:nn

	% case 2: #1 starts with some other token. Then
	%     \use_none:n {{ \string #1 }  \@@casei } \@@caseii } \use_ii:nn
	% expands to
	%     \use_none:n {{ ...        }  \@@casei } \@@caseii } \use_ii:nn
	% and subsequently
	%                                             \@@caseii } \use_ii:nn

	\zdef \@@casei {  % such that '\@@casei } \@@caseii } \use_ii:nn' expands to \use_i:nn
\linemarkeron
		\rcall{\removenextegroup}  %        }
		\rcall{\removeuntilegroup}  %         \@@caseii }
		\matchrm{#1}
		\return {\use_i:nn}
\linemarkeroff
	}

	\zdef \@@caseii {
\linemarkeron
		\rcall{\removenextegroup}
\linemarkeroff
	}
}
!

% remove following '...}' in the input stream (including the '}' itself).
\rdeflinenumbered\removeuntilegroup {
	
	\putnext{\Iexpandtobgroup}
	\expandonce
	\matchrm{#1}
}
%\let\removenextegroup\removeuntilegroup  % no error checking.
% TODO it doesn't work -- need to do this after pending definitions are executed



\imperative_allow_inline: \rdef \putnextbgroup {
	\putnext {\Iexpandtobgroup}
	\expandonce
}

\imperative_allow_inline: \rdef \putnextegroup {
	\putnext {\Iexpandtoegroup}
	\expandonce
}


% mark function as "can be used in a single expansion step"
\odefmark:N \use_i:n
\odefmark:N \use_i:nn
\odefmark:N \use_ii:nn
\odefmark:N \use_none:n
\odefmark:N \use_none:nn
\odefmark:N \use_none:nnn

% TODO optimize this somehow
\imperative_allow_inline: \rdeflinenumbered \dropfirst #1 {
	\backquote{
		\return {
			,O {#1} {
				\matchrm{#a}
			}
		}
	}
}

% check if #1 starts with an explicit space character. (as usual, return \use_i:nn or \use_ii:nn)
\zdeflinenumbered \ifspace #1 {
	\assignoperate #1 { . #1 ~ } {


		\matchrm {#a ~}
		% now #a is a single dot if and only if #1 starts with space. 
		% current state:    \use_i:n { |    ...  }  where | is the current "location"
		% need to expand to \use_i:n { \use_i:nn }  -- if #a is a single dot
		%   or              \use_i:n { \use_ii:nn}  -- otherwise

		% the explicit dot is added because without it,
		% if #1 is '{} <explicit space>', then \matchrm {#a ~} is executed against '{} <explicit space> ~'
		% so #a gets matched to nothing.

		\backquote{
			\conditional {\ifempty {,r{\dropfirst {#a}}}} {
				\assign #b{\use_i:nn}
			}
			{
				\assign #b{\use_ii:nn}
			}
		}
		\assertisNtype #b
		\rcall{\removeuntilegroup}
		\rcall{\putnextegroup}
		\putnext {#b}


	}
	\return {#1}
}

% rdef: romannumeral-based def. \exp:w \macro {arguments...} expands to the result in 1 step.
% internally it's generated using \exp_end:



\zdeflinenumbered \ifnotempty #1 {
	\conditional {\ifempty {#1}} {
		\return {\use_ii:nn}
	} {
		\return {\use_i:nn}
	}
}

%TODO suboptimal
\iffalse
\imperative_allow_inline: \zdeflinenumbered \ifnotempty #1 #2 #3 {
	\conditional {\ifempty {#1}} {
		\return {#3}
	} {
		\return {#2}
	}
}
\fi


% same as UD@ExtractFirstArg
% ignore initial spaces, faster
\addlinemarkerconditionalb {} !\precattl_exec:n {
\rdef \firstarg #x {
\linemarkeron
	% example: #x = {abc \relax de}
	\assign #x{#x \cFrozenRelax}
	% example: #x becomes {abc \relax de \relax}
	\while {\assignr #y {\dropfirst {#x}}}{ \ifnotempty {#y} } {
		\assignoperate #x {#x} {
			% following in the input stream:   #x  =  <first> <something else> \cFrozenRelax
			\matchrm {#\first #\rest \cFrozenRelax}
			\putnext {{#\first}}  % remember to brace it
		}
	}
	% in the example above #x becomes {{a} de \relax}, then finally {{a}}.

	\backquote{
		\return {,o{\use:n #x}}  % remove the outer most brace group.
	}
\linemarkeroff
}
}!

% same as above but the first argument is a single token.
% might be slightly faster, benchmark to be sure.
\rdeflinenumbered \firstargsingletoken #x {
	\putnext {\Iremovebgroup{#x}}
	\expandonce  % remove the bgroup of course.
	\matchrm {#y}  % now #y is the first argument
	\assertisNtype #y
	\rcall{\putnextbgroup}  % input stream: {[newly put]  ... content of remaining of #x ... } with #y "stored"
	\matchrm {#z}
	\return {#y}
}

% same as UD@ExtractFirstComponent
% keep initial spaces, slower
\rdeflinenumbered \firstcomponent #x {
	\conditional{\ifspace {#x}} {
		\return {~}
	} {
		\backquote{
			\return {,r{\firstarg {#x}}}
		}
	}
}

% return the string representation of the first bgroup character.
\rdeflinenumbered \firstbgroup #x {}!
	\while {}{ \ifnotempty {#x} } {
		\conditional {\ifbrace {#x}} {
			% found the first group.

			\assignoperate #y {\string #x} {
				\expandonce
				\rcall{\putnextbgroup}
			}

			% now if #x = {{ab}cd}, then #y = {{'{'ab}cd}
			\backquote{
				\return {,r{\firstcomponent {,r{\firstarg {#y}}}}}
			}
		} {
			\conditional {\ifspace {#x}} {
				\assignr #x{\removespace {#x}}
			} {
				\assignr #x{\dropfirst {#x}}
			}
		}
	}
	\return {}
!

%\cdef  % callback-based def.

\rdeflinenumbered \firstegroup #x {}!
	\while {}{ \ifnotempty {#x} } {
		\conditional {\ifbrace {#x}} {
			% found the first group.

			% first make sure the open brace has charcode `{` (anything not a space will do.).
			\assignoperate #x {\string #x} {
				\expandonce
				\rcall{\putnextbgroup}
			}

			% then empty out that group.
			\while {
				\assignr #\firstcomponent {\firstarg{#x}}
			} {
				\ifnotempty {#\firstcomponent}
			}{
				% firstcomponent is still nonempty. Pick one item
				\conditional{\ifspace {#\firstcomponent}} {
					\assignoperate #x {#x} {
						% following in the input stream:  { <space> ... }  ...
						\putnext{\string} \expandonce
						% following in the input stream:  '{' <space> ... }  ...  where the initial { is stringified and is definitely not a space
						\matchrm{#1 ~}
						% following in the input stream:    ... }  ...
						\rcall{\putnextbgroup}
					}
				} {
					\assignoperate #x {#x} {
						% following in the input stream:  { <item> ... }  ...
						\putnext{\string} \expandonce
						% following in the input stream:  '{' <item> ... }  ...  where the initial { is stringified and is definitely not a space
						\matchrm{#1 #2}
						% following in the input stream:    ... }  ...
						\rcall{\putnextbgroup}
					}
				}
				% now firstcomponent is shorter.
			}

			% finally firstcomponent is empty now. (and the opening brace is guaranteed to be non-space)
			\assignoperate #x {#x} {
				% following in the input stream: { } ...
				\putnext{\string} \expandonce
				% following in the input stream: '{' } ...
				\matchrm{#1}
				% following in the input stream:     } ...
				\putnext{\string} \expandonce
				% following in the input stream:     '}' ...
			}

			% finally done
			\assignr #x{\firstcomponent{#x}}
			\return{#x}

		} {
			\conditional {\ifspace {#x}} {
				\assignr #x{\removespace {#x}}
			} {
				\assignr #x{\dropfirst {#x}}
			}
		}
	}
	\return {}
!


% ========

\directlua{optimize_pending_definitions()}
\directlua{debug_rdef()}
\directlua{print_tlrepr()}
\directlua{execute_pending_definitions()}

\let\removenextegroup\removeuntilegroup  % no error checking.



\precattl_exec:n {
	\pretty:o { \romannumeral \firstbgroup {{1}2} }
	\pretty:o { \romannumeral \firstegroup {{1}2} }

	\pretty:o { \romannumeral \firstbgroup { \cB\A 1 \cE\} 2} }
	\pretty:o { \romannumeral \firstbgroup { \cB\\ 1 \cE\} 2} }
	\pretty:o { \romannumeral \firstbgroup { \cB\  1 \cE\} 2} }

	\pretty:o { \romannumeral \firstegroup { \cB\A 1 \cE\A 2} }
	\pretty:o { \romannumeral \firstegroup { \cB\\ 1 \cE\\ 2} }
	\pretty:o { \romannumeral \firstegroup { \cB\  1 \cE\  2} }

	\pretty:o { \romannumeral \firstegroup { \cB\{  \cE\A 2} }
	\pretty:o { \romannumeral \firstegroup { \cB\{  \cE\\ 2} }
	\pretty:o { \romannumeral \firstegroup { \cB\{  \cE\  2} }
	\pretty:o { \romannumeral \firstegroup { \cB\   \cE\  2} }
}

\prettystop


\makeatother
\ExplSyntaxOff
\end{document}
