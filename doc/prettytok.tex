%! TEX program = lualatex
\ProvidesFile{prettytok.tex} [2022/07/08 v0.0.1 ]
\documentclass{l3doc}
\usepackage[svgnames]{xcolor}
\RequirePackage{fvextra}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\fvset{breaklines=true,gobble=0,tabsize=4,frame=single,numbers=left,numbersep=3pt}
\AtBeginDocument{\DeleteShortVerb\"}
\MakeOuterQuote{"}
\begin{document}
\GetFileInfo{\jobname.tex}
\DoNotIndex{\newcommand,\newenvironment}

\title{\textsf{prettytok} --- Pretty-print token lists\thanks{This file
	describes version \fileversion, last revised \filedate.}
}
\author{user202729%
%\thanks{E-mail: (not set)}
}
\date{Released \filedate}

\maketitle

\changes{v0.0.0}{2022/05/18}{First public release}

\begin{abstract}
Pretty-print token lists for debugging purposes.

Can be used to replace |\tl_analysis_show:n|.
\end{abstract}

\section{Motivation}

\TeX's default mechanism for debug-printing (|\showtokens{...}|, |\typeout{\unexpanded{...}}|, |\show...|) has a few limitations

\begin{itemize}
	\item |\show| and similar is considered an error and stops the TeX run. (this point is partially fixable, see the package author's question \url{https://tex.stackexchange.com/q/621919/250119})
	\item If there's some unprintable character in the output (for example, |^^J|, |^^M|, |^^I| -- literal tab character), it's not easy to distinguish between them.
	\item If some token has unexpected catcode (most commonly, letter versus other), it's not easy to distinguish as well.
	\item They does not work in expansion-only context. (apart from |\msg_expandable_error:nn|, but this one suffers from the first problem as well)
\end{itemize}

|\tl_analysis_show:n| attempts to fix the third problem, but is very, very verbose and does not fix the other problems.

This package aims to fix all of them.

(although the expandable debug printing functions are \LuaTeX-only.)

And some more additional (expandable in \LuaTeX) functions to inspect the content of the input stream at a particular moment in time.


\section{Usage}

See subsection~\ref{subsec:full-example} for a full example.

\subsection{Main function}
\begin{function}{\pretty:n,\pretty:x,\pretty:o,\pretty:V}
	\begin{syntax}
		\cs{pretty:n} \Arg{token list}
	\end{syntax}
	Print the content of \meta{token list}.
\end{function}

\begin{function}{\pretty:N,\pretty:c}
	\begin{syntax}
		\cs{pretty:N} \meta{token}
		\cs{pretty:c} \Arg{control sequence name}
	\end{syntax}
	Print \meta{token}.

	This function is not very useful. Usually it's preferable to use |\pretty:V| to print a token list variable's value,
	or |\prettyshow:N| to print a control sequence's meaning.
\end{function}

\begin{function}{\prettyinit:}
	\begin{syntax}
		\cs{prettyinit:}
	\end{syntax}
	Do necessary initialization for output to HTML file.

	This should be called right after the package is loaded, after setting the configuration variables described below.
\end{function}

\begin{function}{\prettyinitterm:}
	\begin{syntax}
		\cs{prettyinitterm:}
	\end{syntax}
	Same as above. However, if this is used, the information is printed on the terminal instead of to the HTML file.

	This might require |-8bit| option on engines other than \LuaTeX, see \url{https://tex.stackexchange.com/q/168460/250119}.

	Besides, this drops the distinction between the catcode of some tokens (for example \verb|{}$#&^_| are all shown as the same color as "special catcode"),
	which is available in the tooltip in the HTML version.
\end{function}

\subsection{Expandable interface (\LuaTeX\ only)}

\cs{prettyinit:} or \cs{prettyinitterm:} must be called before calling the functions in this section.

\begin{function}[EXP]{\prettye:n}
	\begin{syntax}
		\cs{prettye:n} \Arg{token list}
	\end{syntax}
	Print the token list, similar to \cs{pretty:n}, but is fully expandable.
\end{function}

\begin{function}[EXP]{\prettye:w}
	\begin{syntax}
		\cs{prettye:w} \meta{tokens} \cs{prettystop}
	\end{syntax}
	Print the tokens until \cs{prettystop} is seen. Useful for inspecting the content of the input stream.

	As a debugging tool, it's possible to execute |\everyeof{\prettystop}| to avoid runaway printing in weird catcode environments.
\end{function}

The idea is that it can be inserted "anywhere" without affecting how the function works (as long as the function does not rely on the exact number of expansion steps).

Note that the input stream will be tokenized and has catcode frozen;
besides, currently some implementation details (it can be fixed, but the package author does not
have an immediate need for it, see \url{https://tex.stackexchange.com/q/335994/250119}) means control sequences not
in the hash table will be destroyed.
Use with care.

For example
\begin{verbatim}
\ExplSyntaxOn
\def \f #1 {\prettye:w 789}
\f 123456 \prettystop
\end{verbatim}
will print out |78923456|.

\subsection{Lua programming interface}

\cs{prettyinit:} must also be called before calling the functions in this section.

\begin{function}{prettyprint}
	\begin{syntax}
		|prettyprint(|\meta{content}|)|
	\end{syntax}
	Print the content, which should be a table of token objects.

	For convenience, you can pass multiple arguments. Strings are also supported.
\end{function}


\subsection{View result}

If terminal output is selected, the output is on the terminal, no special action required. (although see the note on |-8bit| above)

Otherwise, the result is printed to a HTML file named |pretty-|\meta{jobname}|.html| by default.
Open the file in any browser to view the result.

Note that the HTML file will not be touched if nothing is printed, as such it's encouraged to add a line such as |\pretty:n {start}| right after loading the file.

Why HTML file?

\begin{itemize}
	\item If the \TeX\ program stops with error / has some error that corrupts the PDF output, the output will even with corrupted more by the debug print.
	\item Printing to the console is extremely limited (difficult syntax highlighting/scrolling/line wrapping), and most likely cluttered with the traceback/other \TeX\ default output.

		(nevertheless, there might be plan to support output to console with syntax highlighting later.)
	\item Output to another \TeX\ file to be compiled works as well; however it's necessary to run another instance of |latexmk| (or other tool used to compile \TeX\ code)
		and compiling \TeX\ file takes longer than loading a HTML file.
\end{itemize}

By default, the output refreshes whenever the \TeX\ file is recompiled. The behavior
can be customized with \cs{prettyrefreshstrategy} and \cs{prettyrefreshduration}.

\subsection{Additional functions}

There are also these functions, for convenience.

\begin{function}{\pretty:nn, \pretty:nnn}
	\begin{syntax}
		\cs{pretty:nn} \Arg{token list} \Arg{token list}
		\cs{pretty:nnn} \Arg{token list} \Arg{token list} \Arg{token list}
	\end{syntax}
	Print multiple token lists. Its effect is similar to multiple consecutive calls to \cs{pretty:n}.
\end{function}

\begin{function}[EXP]{\prettye:nn, \prettye:nnn}
	\begin{syntax}
		\cs{prettye:nn} \Arg{token list} \Arg{token list}
		\cs{prettye:nnn} \Arg{token list} \Arg{token list} \Arg{token list}
	\end{syntax}
	Similar to multiple consecutive calls to \cs{prettye:n}.
\end{function}

\begin{function}[EXP]{\prettye:nw, \prettye:nnw}
	\begin{syntax}
		\cs{prettye:nw} \Arg{token list} \meta{tokens} \cs{prettystop}
		\cs{prettye:nnw} \Arg{token list} \Arg{token list} \meta{tokens} \cs{prettystop}
	\end{syntax}
	Similar to call(s) to \cs{prettye:n} followed by a call to \cs{prettye:w}.
\end{function}

\begin{function}{\pretty:w}
	\begin{syntax}
		\cs{pretty:w} \meta{token list} \cs{prettystop}
	\end{syntax}
	Print the content of \meta{token list}.

	Same restriction applies -- the catcode is frozen.

	In addition -- for now, it must be brace-balanced.  Use \cs{prettye:w} instead if possible.
\end{function}

\begin{function}[EXP]{\prettystop}
	\begin{syntax}
		\cs{prettystop}
	\end{syntax}
	Only used as a delimiter for |:w| functions. For convenience, this function is defined to do nothing.
\end{function}

\begin{function}{\prettyshow:N,\prettyshow:c}
	\begin{syntax}
		\cs{prettyshow:N} \meta{token}
		\cs{prettyshow:c} \Arg{control sequence name}
	\end{syntax}
	Show the meaning of a |N|-type argument.
\end{function}

\subsection{\LaTeXe\ interface}

\begin{function}{\prettyN,\prettyX,\prettyO,\prettyV,\prettyinit,\prettyinitterm\prettyshowN,\prettyshowC}
	\begin{syntax}
		\tn{prettyN} \Arg{token list}
		\tn{prettyX} \Arg{token list}
		\tn{prettyO} \Arg{token list}
		\tn{prettyV} \meta{tl var}
		\tn{prettyinit}
		\tn{prettyinitterm}
		\tn{prettyshowN} \meta{token}
		\tn{prettyshowC} \Arg{control sequence name}
	\end{syntax}
	Alias of the correspondingly-named commands.
\end{function}

\begin{function}[EXP]{\prettyeN,\prettyeW}
	\begin{syntax}
		\cs{prettyeN} \Arg{token list}
		\cs{prettyeW} \meta{tokens} \cs{prettystop}
	\end{syntax}
	Alias of the correspondingly-named commands. Only available in \LuaTeX.
\end{function}

\subsection{\label{subsec:full-example}Full example}

For a full example, the following code, which prints several things, both using the \LaTeXe\ interface
and using the \pkg{expl3}-style interface, using both expandable and unexpandable command (the former requires \LuaTeX, as mentioned above):
\begin{verbatim}
\documentclass{article}
\usepackage{prettytok}

\prettyinitterm

\prettyN{123{4 5}\6}
\prettyN{#&^_:}
\edef\mytest{\prettyeN{\error}}

\prettyN {very long long long long long long long long long long long long long long argument \argument\argument\test123456}
\prettyeN {very long long long long long long long long long long long long long long argument \argument\argument\test123456}

\ExplSyntaxOn
\pretty:n {#&^_:}
\ExplSyntaxOff

\begin{document}
\end{document}
\end{verbatim}
The corresponding output (in the current version) is:
\begingroup%
\ExplSyntaxOn

\definecolor{myyellow}{RGB}{173, 174, 0}
\definecolor{mygreen}{RGB}{52, 174, 0}

\let \\ \textbackslash
\def \cmd#1{\textcolor{myyellow}{\textbf{\textbackslash}#1}}
\def \spec#1 {\textcolor{red}{#1}}
\def \letr#1 {\textcolor{mygreen}{#1}}
\setlength{\parindent}{0pt}
\frenchspacing   %  no double space after dot

\catcode`␣\active    \def␣{\textbf{\textcolor{gray!60}{\char32}}}

\ExplSyntaxOff
\small%
\obeylines%
\texttt{
> 123\spec\{4␣5\spec\}\cmd{6}
> \spec{\#\&\textasciicircum\_}:
> \cmd{error}
> \letr{very␣long␣long␣long␣long␣long␣long␣long␣long␣long␣long␣long␣long␣long␣long␣argument}␣\cmd{argument}
> .. \cmd{argument} \cmd{test} 123456
> \letr{very␣long␣long␣long␣long␣long␣long␣long␣long␣long␣long␣long␣long␣long␣long␣argument}␣\cmd{argument}
> .. \cmd{argument} \cmd{test} 123456
> \spec{\#\&\textasciicircum}\letr{\_:}
}\endgroup

\subsection{Customization for HTML output}

These variables can be redefined before the
first call to \cs{pretty:n} or \cs{prettyinit:} to customize the behavior.

\begin{variable}{\prettyfilename}
	The output file name. Defaults to |pretty-|\meta{jobname}|.html|, as mentioned above.
\end{variable}

\begin{variable}{\prettyrefreshstrategy}
	The auto-refresh strategy. Allowed values are 0-4. 0 is no refresh. \\
	Which value works best depends on the particular browser. \\
	On Google Chrome, passing |--allow-file-access-from-files| may be useful.
\end{variable}

\begin{variable}{\prettyrefreshduration}
	The duration between two consecutive refresh check, in milliseconds. Defaults to 1000.
\end{variable}

\subsection{Customization for terminal output}

\begin{variable}{\prettytermprefix,\prettytermprefixmore}
	Strings consist of prefixes to be output before each terminal line.

	This might be useful for log-filtering/output-filtering tools such as |texfot| to recognize the output line.

	Defaults to \verb*|> | and \verb*|> .. | respectively.
\end{variable}

\begin{variable}{\prettytermwraplimit}
	Estimated line length limit. Set this to a little smaller than your terminal width.

	Note that this is a \meta{tl var}, so it should be set like |\tl_gset:Nn \prettytermwraplimit {80}| instead of |\int_set:Nn \prettytermwraplimit {80}|.
\end{variable}

\section{Implementation}

Unfortunately, the implementation is not typesetted in \TeX. Read the |.sty| file.

Remark: it's possible to do expandable printing in other engines as well by, for example, turning on `\tracingmacros`, parse the token list somehow
(and use some not-always-exact logic to distinguish normal character and active character with same meaning;
then grep the resulting log file for special markers.

But that would be very, very slow and slows down everything else by turning on logging. Just use \LuaTeX\ for debugging.

There's another option of recompiling the engine and adding some expandable primitive for debug logging...

\PrintChanges
\PrintIndex
\Finale
\end{document}
